#!/usr/bin/env pinpoint

[fill]
[white]
[center]
[text-align=center]
[bg.jpg]
[duration=45.0]

-- [airplane_500.jpg]

<span size="large" weight="heavy">Rebuilding the airplane at 10 000m</span>
Continuous Deployment with Jenkins and Gerrit

<span size="xx-small">R. Tyler Croy
tyler@linux.com</span>

# Hello and thanks for coming. I'm R. Tyler Croy, and today I'm going to talk
# to you about two things at the same time!
#
# I'm going to tell you how we rebuilt our engineering organization
# "mid-flight" for Continuous Deployment and at the same time, I'm going to
# tell you how you can too with Jenkins and Gerrit

-- [lookout_frontdesk.jpg] [right]

I work for Lookout

# First of all, I work at Lookout Mobile Security, if you're an Android user
# you might already be familiar with some of our products.
#
# If you're not familar with us, we are primarily known for our security app on
# Android.
#
# My job at Lookout primarily involves ->

-- [terminal_ruby.png]

Hacking with Ruby

# Hacking with Ruby, you see while we have a nice fancy Java-based Android
# application, we also have a *large* server-backend which handles device
# notifications, backups, analysis and much more.
#
# That entire backend is written in Ruby, and can benefit from ->

--

Let's talk about:
<b>continuous deployment</b>

# Continuous Deployment.
#
# Before I talk too much about what it *is*, I'd like to talk about ->

-- [cd-jira.png]

What it is:
<span weight="bold" size="large" foreground="red">NOT</span>

# What Continuous Deployment is NOT.
#
# Above all else, it is not something you do *once* and then you're finished
# and you can move on. Continous Deployment is a process and mind-set you and
# your team stick with

-- [broken_table.jpg]

"Release <i>everything</i>
as soon as possible!"

# Continuous Deployment doesn't mean you release EVERYTHING as soon as it's
# committed. Nor does it mean you must deploy every single commit.
#
# (photo by thomen: <http://www.flickr.com/photos/thomen/364890522/>)

-- [broken_table.jpg]

"Great! No need for a QA team"

# One of the interesting things I've discovered at Lookout and at other
# organizations, is that Continuous Deployment, and some of the practices
# involved in it is that it will free up the QA team to *do their jobs*.
#
# Good QA engineers are most useful when they're exploring, hunting for bugs.
# Having QA engineers running through test plans every day of the week is
# boring, slow and is a good candidate for replacement with automated testing
# tools

-- [broken_table.jpg]

"Our users will be our testers!"

# Lastly, I don't think Continuous Deployment means you can offload testing to
# your users.
#
# To some extent this will be inevitable, as changes are more rapidly deployed,
# but I believe you should try everything you can to avoid your users
# experiencing issues because of bugs you've introduced

--

Continuous Deployment
is about

# Continous Deployment, in my opinion, is all about ->

-- [norris_test_trend.png] [fit]

<b>stability</b>

# stability. It is about being able to deploy changes ->

--

<b>Faster</b>
with
<b>More Confidence</b>

# Continuous Deployment is about releasing changes faster, and with more
# confidence in the changes you're preparing the release.
#
# In order to make that happen, it is important to have *good* procedures for
# rapid deployment and an excellent feedback loop from production. These two
# factors, above anything else will enable you to ship code rapidly and
# maintain quality.

--

Continuous Deployment is
<span weight="heavy" size="large" foreground="green">GOOD</span>

-- [lookout_frontdesk.jpg] [right]

Meanwhile at Lookout

-- [svn-branches.png] [top]

Subversion branches for releases

--- [subversion-timeline.png] [bottom]

10-18 days per release branch

--

very little automation

--

<b>Sadness with Numbers</b>

--

<span size="xx-large" weight="bold">36%</span>
of deployments failed

--

<span size="xx-large" weight="bold">68</span>
commits per deployment

--

<span size="xx-large" weight="bold">62%</span>
of deployments slipped

-- [sad-cat.jpg] [top]

--

Let's <b>fix</b> this.

-- [robot_assembly.jpg]

Step One:
<b>Automate</b>

-- [robot_assembly.jpg]

<span weight="bold">Jenkins</span>

# Before we used a tool called Bitten, I won't tell you too much about Bitten,
# but it's not a great tool and we had a number of issues with it:
#   * Practically zero developer insight into the test/build process
#   * All the tests ran on *one* build machine which was hand-crafted by the
#     Operations team for the task
#
# We installed Jenkins and started to work on migration "jobs" over to Jenkins.

-- [robot_assembly.jpg]

"Why don't our tests pass?"

# The first major issue we had was that we noticed that we had tests that
# didn't actually *pass* reliably. Previously this was hidden from us, but
# after running the tests after every commit with Jenkins, we noticed that we
# had some technical debt in the test suite

-- [good-tools.jpg]

Step Two
<b>Use better tools</b>

# The second important step we took towards continuous deployment was to use
# *better* tools and processes than we were using

-- [good-tools.jpg]

(<i>I don't like SVN</i>)

# I'm not going to rant against Subversion here, if you like it, that's fine.
# There are ways to accomplish continuous deployment with Subversion. At
# Lookout however, I viewed it as one of the things standing in our way.
#
# So we got rid of Subversion and instead opted for ->

-- [good-tools.jpg]

<b>Git + Gerrit</b>

# Git and Gerrit
#
# I'm going to assume you know about Git or at least some kind of distributed
# version control system, so let me tell you about Gerrit.

-- [gerrit-screenshot-bg.png]

<b>Gerrit</b>

# Gerrit is a Git-based code review tool

-- [codereview-gerrit.png] [top]

code review

-- [collab-diff.png] [top]

collaboration

-- [gerrit-workflow.png] [top]

# TODO: Perhaps this should go after the pre-tested commits bit

<b>Git + Gerrit</b>
at the same time!

# We switched from Subversion directly to Git and Gerrit, all at once.
#
# Instead of introducing Git as a separate tool to developers, we introduced
# at the same time so developers never learned a Git-based workflow that
# *didn't* involve Gerrit at its core.

-- [gerrit-workflow.png] [top]

Training the team

# We scheduled 3 different 1 hour training sessions with various groups of
# engineers in order to provide a hands-on walk-through of the Git + Gerrit
# workflow
#
# This included a fully set-up "demo" project to use for experimentation of
# creating commits, code reviewing them, verifying them with Jenkins and
# finally merging them into the "master" bracnh
#
# During the course of these training sessions, we used the feedback and common
# problems encountered by engineers to fill out a "getting started" wiki page
# which new hires now use to come up to speed with Git + Gerrit.

-- [gerrit-pretested-workflow.png] [top]

"Pre-tested" Commits

# An integral part of our Git + Gerrit workflow involved pre-testing commits.
#
# The whole concept behind "pre-testing" a commit is that only changes which
# have passed the "tests" will be allowed to be integrated or merged.

-- [gerrit-trigger-diagram.png] [fit]

<b>Gerrit Trigger plugin</b>


# Gerrit Trigger plugin

-- [trigger-feedback.png] [top]

Feedback in Gerrit

-- [gerrit-pretested-workflow.png] [top]

The Cycle

--

# TODO: Make this less out of place
"We need more builders!"

# When we first started moving things into Jenkins we had 3 slaves that were
# properly configured for running our tests. As we started using pre-tested
# commits with Gerrit and Jenkins, we *very* quickly realized that we needed
#
# In the very early stages of this, we used the same hand-crafted VM base image
# with VMWare ESX, and then spun up multiple new machines.
#
# This process has changed a bit since then, which I'll dig into in a moment

--

<b>Recap</b>

# TODO: Diagram and cover "the world thus far"

--

Step Three
<b>Automate <i>Everything</i></b>

--

Managing slaves?

--

New kinds of tests!

--

Automating <b>deployment</b>

# First automating with `infra_update_faithful2` then moving into the
# `infra_deploy_qa` territory. Finally automating the actual deployment of
# production
--

Deploying the test environment


# Once the deployment of our test environment was managed through Jenkins,
# we created pipelines with Jenkins, chaining off of a successful
# deployment to the test environment.
#
# TODO: Discuss selenium testing/SI testing after QA deploy
--

Deploying the <i>production</i> environment

# TODO: Discuss the use of build promotions to stage, deploy and finally mark
# the deployment as successful

--

<b>TODO</b>

--

(<i>nobody's perfect</i>)

--

* Haven't automated the rollback of production
* Not nearly enough stages/production clusters to run Selenium tests per-commit
* Not enough real-time feedback from production
* No production acceptance testing
* Tests take a LONG time
* Still only doing a single daily deployment, facing the same issues we did before with 2 week deployment, but on a smaller scale

--

<b>Happiness with Numbers</b>

--

<span size="xx-large" weight="bold">2%</span>
of deployments failed

--

<span size="xx-large" weight="bold">14</span>
commits per deployment

--

<span size="xx-large" weight="bold">3%</span>
of deployments slipped

-- [happy-cat.jpg] [top]

(<i>that <b>rocks!</b></i>)

--

Questions?
