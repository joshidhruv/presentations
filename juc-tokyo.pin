#!/usr/bin/env pinpoint

[fill]
[white]
[center]
[text-align=center]
[bg.jpg]

-- [airplane_500.jpg]

<span size="large" weight="heavy">Rebuilding the airplane at 10 000m</span>
Continuous Deployment with Jenkins and Gerrit

<span size="xx-small">R. Tyler Croy
tyler@linux.com</span>

-- [lookout_frontdesk.jpg] [right]

I work for Lookout

-- [terminal_ruby.png]

Hacking with Ruby

--

Let's talk about:
<b>continuous deployment</b>

-- [cd-jira.png]

What it is:
<span weight="bold" size="large" foreground="red">NOT</span>

# First, I want to mention what Continuous Deployment is not about.
#
# Above all else, it is not something you do *once* and then you're finished
# and you can move on. Continous Deployment is a process and mind-set you and
# your team stick with

-- [broken_table.jpg]

"Release <i>everything</i>
as soon as possible!"

# (photo by thomen: <http://www.flickr.com/photos/thomen/364890522/>)

-- [broken_table.jpg]

"Great! No need for a QA team"

-- [broken_table.jpg]

"Our users will be our testers!"

--

Continuous Deployment
is about

# Continous Deployment, in my opinion, is all about ->

-- [norris_test_trend.png] [fit]

<b>stability</b>

# stability. It is about being able to deploy changes ->

--

<b>Faster</b>
with
<b>More Confidence</b>

# Continuous Deployment is about releasing changes faster, and with more
# confidence in the changes you're preparing the release.
#
# In order to make that happen, it is important to have *good* procedures for
# rapid deployment and an excellent feedback loop from production. These two
# factors, above anything else will enable you to ship code rapidly and
# maintain quality.

--

Continuous Deployment is
<span weight="heavy" size="large" foreground="green">GOOD</span>

--

<i>in the olden days</i>

--

Subversion branches for releases

TODO: create background image

--- [top]

10-18 days per release branch

--

very little automation

--

:(

--

<b>Sadness with Numbers</b>

--

<span size="xx-large" weight="bold">36%</span>
of deployments failed

--

<span size="xx-large" weight="bold">68</span>
commits per deployment

--

<span size="xx-large" weight="bold">62%</span>
of deployments slipped

-- [sad-cat.jpg] [top]

(<i>that sucks</i>)

--

Let's <b>fix</b> this.

-- [robot_assembly.jpg]

Step One:
<b>Automate</b>

-- [robot_assembly.jpg]

<span strikethrough="true">Bitten</span>
<span weight="bold">Jenkins</span>

# I won't tell you too much about Bitten, but it's not a great tool and we had
# a number of issues with it:
#   * Practically zero developer insight into the test/build process
#   * All the tests ran on *one* build machine which was hand-crafted by the
#     Operations team for the task
#   * We would constantly have issues with Bitten losing track of test
#     processes
# We installed Jenkins and started to work on migration "jobs" over to Jenkins.
#
# Since our Bitten installation was so backwards, we ended up building a number
# of jobs "from scratch."

-- [robot_assembly.jpg]

"Why don't our tests pass?"

# The first major issue we had was that we noticed that we had tests that
# didn't actually *pass* reliably. Previously this was hidden from us, but
# after running the tests after every commit with Jenkins, we noticed that we
# had some technical debt in the test suite

-- [robot_assembly.jpg]

"We need build machines!"

# Once we started running more tests more often with Jenkins we found out very
# quickly that we needed to start to create a build slave infrastructure.
#
# For the first few months we relied on a hand-crafted VMWare snapshot, which
# we used to start up a pool of machines that all looked the same

--

Step Two
<b>Die Subversion, Die</b>

--

(<i>I don't like SVN</i>)

--

<b>Git + Gerrit</b>


# I'm going to assume you know about Git or at least some kind of distributed
# version control system, so let me tell you about Gerrit.

-- [gerrit-screenshot-bg.png]

<b>Gerrit</b>


# Gerrit is a Git-based code review tool
# TODO: Fill this in more

-- [gerrit-workflow.png] [top]

<b>Git + Gerrit</b>
at the same time!

# We switched from Subversion directly to Git and Gerrit, all at once.
#
# Instead of introducing Git as a separate tool to developers, we introduced
# at the same time so developers never learned a Git-based workflow that
# *didn't* involve Gerrit at its core.

--

Git + Gerrit
<b>Training the Team</b>

# We scheduled 3 different 1 hour training sessions with various groups of
# engineers in order to provide a hands-on walk-through of the Git + Gerrit
# workflow
#
# This included a fully set-up "demo" project to use for experimentation of
# creating commits, code reviewing them, verifying them with Jenkins and
# finally merging them into the "master" bracnh

--

Document <i>everything</i>

# During the course of these training sessions, we used the feedback and common
# problems encountered by engineers to fill out a "getting started" wiki page
# which new hires now use to come up to speed with Git + Gerrit.

-- [gerrit-pretested-workflow.png] [top]

"Pre-tested" Commits

# An integral part of our Git + Gerrit workflow involved pre-testing commits.
#
# The whole concept behind "pre-testing" a commit is that only changes which
# have passed the "tests" will be allowed to be integrated or merged.

--

Featuring the:
<b>Gerrit Trigger plugin</b>

--

"We need more builders!"

# When we first started moving things into Jenkins we had 3 slaves that were
# properly configured for running our tests. As we started using pre-tested
# commits with Gerrit and Jenkins, we *very* quickly realized that we needed
#
# In the very early stages of this, we used the same hand-crafted VM base image
# with VMWare ESX, and then spun up multiple new machines.
#
# This process has changed a bit since then, which I'll dig into in a moment

--

<b>Recap</b>

# TODO: Diagram and cover "the world thus far"

--

Step Three
<b>Automate <i>Everything</i></b>

--

Managing slaves?

--

New kinds of tests!

--

Automating <b>deployment</b>

# First automating with `infra_update_faithful2` then moving into the
# `infra_deploy_qa` territory. Finally automating the actual deployment of
# production
--

Deploying the test environment


# Once the deployment of our test environment was managed through Jenkins,
# we created pipelines with Jenkins, chaining off of a successful
# deployment to the test environment.
#
# TODO: Discuss selenium testing/SI testing after QA deploy
--

Deploying the <i>production</i> environment

# TODO: Discuss the use of build promotions to stage, deploy and finally mark
# the deployment as successful

--

<b>TODO</b>

--

(<i>nobody's perfect</i>)

--

* Haven't automated the rollback of production
* Not nearly enough stages/production clusters to run Selenium tests per-commit
* Not enough real-time feedback from production
* No production acceptance testing
* Tests take a LONG time
* Still only doing a single daily deployment, facing the same issues we did before with 2 week deployment, but on a smaller scale

--

<b>Happiness with Numbers</b>

--

<span size="xx-large" weight="bold">2%</span>
of deployments failed

--

<span size="xx-large" weight="bold">14</span>
commits per deployment

--

<span size="xx-large" weight="bold">3%</span>
of deployments slipped

-- [happy-cat.jpg] [top]

(<i>that <b>rocks!</b></i>)

--

Questions?
